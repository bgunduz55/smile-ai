import * as vscode from 'vscode';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';
import { sleep } from '../utils/utils';
import * as WebSocket from 'ws';

// WebSocket tipi i√ßin yardƒ±mcƒ± deƒüi≈üken
const WebSocketClass = (WebSocket as any).WebSocket || WebSocket;

// WebSocket readyState values as constants with explicit types
const WS_CONNECTING: number = 0;
const WS_OPEN: number = 1;
const WS_CLOSING: number = 2;
const WS_CLOSED: number = 3;

// MCP Mesaj Tipleri
export enum McpMessageType {
    INIT = 'init',
    QUERY = 'query',
    RESPONSE = 'response',
    ERROR = 'error',
    FILE_READ = 'file_read',
    FILE_WRITE = 'file_write',
    CODE_ANALYSIS = 'code_analysis',
    COMMAND_EXECUTION = 'command_execution',
    CHAT_MESSAGE = 'chat_message',
    CHAT_RESPONSE = 'chat_response',
    CHAT_STREAM = 'chat_stream',
}

// Server side task types
export enum AgentTaskType {
    CODE_COMPLETION = 'code_completion',
    CODE_EXPLANATION = 'code_explanation',
    CODE_REFACTOR = 'code_refactor',
    CODE_REVIEW = 'code_review',
    CODE_GENERATION = 'code_generation',
    COMMAND_EXECUTION = 'command_execution',
}

// MCP Mesajƒ±
export interface McpMessage {
    id: string;
    type: McpMessageType;
    payload: any;
}

// MCP ƒ∞stemci yapƒ±landƒ±rmasƒ±
export interface McpClientConfig {
    serverUrl: string;
    reconnectInterval?: number;
    maxReconnectAttempts?: number;
}

/**
 * SmileAgent Server ile ileti≈üim kuran MCP istemci sƒ±nƒ±fƒ±
 */
export class MCPClient extends EventEmitter implements vscode.Disposable {
    private socket: WebSocket.WebSocket | null = null;
    private isConnected = false;
    private reconnectAttempts = 0;
    private pendingMessages: Map<string, {
        resolve: (value: any) => void;
        reject: (reason: any) => void;
        timeout: NodeJS.Timeout;
    }> = new Map();
    private config: McpClientConfig;

    constructor(config: McpClientConfig) {
        super();
        this.config = {
            reconnectInterval: 5000,
            maxReconnectAttempts: 5,
            ...config
        };
    }

    /**
     * Sunucuya baƒülanƒ±r
     */
    public async connect(): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            try {
                console.log('üîÑ [MCPClient.connect] Baƒülantƒ± giri≈üimi ba≈ülatƒ±lƒ±yor...');
                
                if (this.socket && (this.socket.readyState as number) === WS_OPEN) {
                    console.log('‚úÖ [MCPClient.connect] Zaten baƒülƒ±, yeni baƒülantƒ± gerekmiyor');
                    this.isConnected = true;
                    resolve();
                    return;
                }
                
                // Eƒüer varsa mevcut soketi kapat
                if (this.socket) {
                    console.log('üîÑ [MCPClient.connect] Aktif soket bulundu, kapatƒ±lƒ±yor...');
                    
                    // Only close the socket if it's not already closing or closed
                    if ((this.socket.readyState as number) !== WS_CLOSING && 
                        (this.socket.readyState as number) !== WS_CLOSED) {
                        try {
                            this.socket.close();
                        } catch (closeError) {
                            console.warn('‚ö†Ô∏è [MCPClient.connect] Error closing existing socket:', closeError);
                        }
                    }
                    this.socket = null;
                }
                
                console.log(`üîÑ [MCPClient.connect] WebSocket baƒülantƒ±sƒ± kuruluyor: ${this.config.serverUrl}`);
                
                // Socket olu≈üturma ve baƒülantƒ± kurma
                try {
                    // WebSocket yerine WebSocketClass kullanƒ±yoruz (TypeScript hatasƒ±nƒ± gidermek i√ßin)
                    this.socket = new WebSocketClass(this.config.serverUrl);
                    console.log('üîÑ [MCPClient.connect] WebSocket yapƒ±cƒ±sƒ± √ßaƒürƒ±ldƒ±, socket:', 
                              this.socket ? 'olu≈üturuldu' : 'null',
                              'readyState:', this.socket ? this.socket.readyState : 'N/A');
                } catch (socketError) {
                    console.error('‚ùå [MCPClient.connect] WebSocket olu≈üturulurken hata:', socketError);
                    reject(new Error(`WebSocket creation failed: ${socketError instanceof Error ? socketError.message : String(socketError)}`));
                    return;
                }
                
                // Socket olaylarƒ±nƒ± dinle
                if (this.socket) {
                    // Define error handler outside the event listeners for reuse
                    const errorHandler = (error: any) => {
                        console.error('‚ùå [MCPClient.connect] WebSocket error:', error);
                        this.isConnected = false;
                        this.emit('error', error);
                        if (!this.isConnected) {
                            reject(error);
                        }
                    };
                    
                    // Define timeout handler outside for reuse
                    let timeoutId: NodeJS.Timeout;
                    const setConnectionTimeout = () => {
                        timeoutId = setTimeout(() => {
                            console.error('‚è±Ô∏è [MCPClient.connect] Connection timeout occurred');
                            if (this.socket) {
                                // Remove all listeners before closing to prevent callbacks
                                this.socket.removeAllListeners?.();
                                this.socket.close();
                                this.socket = null;
                            }
                            reject(new Error('Connection timeout'));
                        }, 10000);
                    };
                    
                    // Set the timeout
                    setConnectionTimeout();
                    
                    this.socket.on('open', () => {
                        console.log('üéâ [MCPClient.connect] WebSocket baƒülantƒ±sƒ± a√ßƒ±ldƒ±');
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        
                        // Clear the timeout
                        clearTimeout(timeoutId);
                        
                        this.emit('connected');
                        
                        // Socket durumunu kontrol et ve log'a yaz
                        if (this.socket) {
                            console.log('üîÑ [MCPClient.connect] WebSocket a√ßƒ±ldƒ±ktan sonra durum:',
                                      'readyState:', this.socket.readyState || 'N/A',
                                      'bufferedAmount:', this.socket.bufferedAmount || 'N/A');
                            
                            // Send a test query immediately to verify the connection is working properly
                            try {
                                console.log('üß™ [MCPClient.connect] Sending test message to verify connection...');
                                const testMsg: McpMessage = {
                                    id: uuidv4(),
                                    type: McpMessageType.QUERY,
                                    payload: {
                                        query: "Test connection",
                                        test: true
                                    }
                                };
                                
                                const testMessageStr = JSON.stringify(testMsg);
                                console.log('üì§ [MCPClient.connect] Test message content:', testMessageStr);
                                
                                // Send the test message
                                this.socket.send(testMessageStr);
                                console.log('‚úÖ [MCPClient.connect] Test message sent successfully');
                            } catch (testError) {
                                console.error('‚ùå [MCPClient.connect] Error sending test message:', testError);
                                // Don't reject here, we'll still consider the connection successful
                                // But log the error for diagnostics
                            }
                        }
                        
                        resolve();
                    });
                    
                    this.socket.on('message', (data: any) => {
                        // If this is our first message, and we were waiting for a response, 
                        // clear the timeout in case it hasn't triggered yet
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        
                        try {
                            console.log('üì• [MCPClient.socket.onmessage] Yanƒ±t alƒ±ndƒ±, raw data tipi:', typeof data);
                            
                            // WebSocket mesajƒ± parse et - UTF-8 karakter kodlama d√ºzeltmesi
                            let message: McpMessage;
                            let jsonString: string;
                            
                            if (typeof data === 'string') {
                                jsonString = data;
                            } else if (data instanceof Buffer) {
                                jsonString = data.toString('utf8');
                            } else if (typeof data.toString === 'function') {
                                jsonString = data.toString();
                            } else {
                                console.error('‚ùå [MCPClient.socket.onmessage] Ge√ßersiz mesaj formatƒ±:', typeof data);
                                return;
                            }
                            
                            // UTF-8 karakter sorunlarƒ±nƒ± kontrol et
                            try {
                                message = JSON.parse(jsonString);
                            } catch (parseError) {
                                console.error('‚ùå [MCPClient.socket.onmessage] JSON parse hatasƒ±, UTF-8 d√ºzeltmesi denenecek:', parseError);
                                // Bazƒ± √∂zel karakter sorunlarƒ±nƒ± d√ºzeltmeyi deneyelim
                                jsonString = jsonString.replace(/\\u([0-9a-fA-F]{4})/g, (_, p1) => String.fromCharCode(parseInt(p1, 16)));
                                message = JSON.parse(jsonString);
                            }
                            
                            // Check for test response
                            if (message.type === McpMessageType.RESPONSE && 
                                message.payload?.result?.test === true) {
                                console.log('‚úÖ [MCPClient.socket.onmessage] Test connection successful!');
                                this.emit('testConnectionSuccess');
                            }
                            
                            // Mesajƒ± i≈üle
                            console.log(`üì© [MCPClient.socket.onmessage] Mesaj alƒ±ndƒ±, Tip: ${message.type}, ID: ${message.id}`);
                            this.handleMessage(message);
                        } catch (parseError) {
                            console.error('‚ùå [MCPClient.socket.onmessage] JSON parse hatasƒ±:', parseError);
                            console.log('‚ùå [MCPClient.socket.onmessage] Hata veren data:', typeof data === 'string' ? data.substring(0, 200) : data);
                        }
                    });
                    
                    this.socket.on('error', errorHandler);
                    
                    this.socket.on('close', (code: number, reason: string) => {
                        console.log(`üîå [MCPClient.socket.onclose] WebSocket baƒülantƒ±sƒ± kapandƒ±. Kod: ${code}, Neden: ${reason}`);
                        this.isConnected = false;
                        this.socket = null;
                        this.emit('disconnected');
                        
                        // Clear timeout if still active
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        
                        // Yeniden baƒülantƒ± dene
                        this.attemptReconnect();
                    });
                }
            } catch (error) {
                console.error('‚ùå [MCPClient.connect] Genel baƒülantƒ± hatasƒ±:', error);
                reject(error);
            }
        });
    }

    /**
     * Sunucu baƒülantƒ±sƒ±nƒ± kapatƒ±r
     */
    public disconnect(): void {
        console.log('üîÑ [MCPClient.disconnect] WebSocket baƒülantƒ±sƒ± kapatƒ±lƒ±yor');
        if (this.socket && this.isConnected) {
            this.socket.close();
            this.isConnected = false;
            this.socket = null;
            console.log('‚úÖ [MCPClient.disconnect] WebSocket baƒülantƒ±sƒ± ba≈üarƒ±yla kapatƒ±ldƒ±');
        } else {
            console.log('‚ÑπÔ∏è [MCPClient.disconnect] Kapatƒ±lacak aktif baƒülantƒ± yok');
        }
    }

    /**
     * Sorgu mesajƒ± g√∂nderir ve yanƒ±tƒ± bekler
     */
    public async sendQuery(query: string, context: any = {}, taskType: string = AgentTaskType.CODE_GENERATION): Promise<any> {
        console.log('\nüì§ [MCPClient.sendQuery] MCP Sorgusu g√∂nderiliyor:');
        console.log(`üí¨ [MCPClient.sendQuery] Sorgu: ${query.substring(0, 50)}${query.length > 50 ? '...' : ''}`);
        console.log(`üìã [MCPClient.sendQuery] Task Tipi: ${taskType}`);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

        // Baƒülantƒ± kontrol√º
        if (!this.isConnectedToServer()) {
            console.error('‚ùå [MCPClient.sendQuery] Server\'a baƒülantƒ± yok!');
            throw new Error('Not connected to SmileAgent Server');
        }

        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.QUERY,
            payload: {
                query,
                context,
                taskType
            }
        };

        return this.sendMessage(message);
    }

    /**
     * Dosya okuma mesajƒ± g√∂nderir
     */
    public async readFile(filePath: string): Promise<string> {
        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.FILE_READ,
            payload: {
                path: filePath
            }
        };

        const response = await this.sendMessage(message);
        return response.content;
    }

    /**
     * Dosya yazma mesajƒ± g√∂nderir
     */
    public async writeFile(filePath: string, content: string): Promise<boolean> {
        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.FILE_WRITE,
            payload: {
                path: filePath,
                content
            }
        };

        const response = await this.sendMessage(message);
        return response.success;
    }

    /**
     * Kod analizi mesajƒ± g√∂nderir
     */
    public async analyzeCode(code: string, language: string): Promise<any> {
        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.CODE_ANALYSIS,
            payload: {
                code,
                language
            }
        };

        return this.sendMessage(message);
    }

    /**
     * Komut y√ºr√ºtme mesajƒ± g√∂nderir
     */
    public async executeCommand(command: string, workingDirectory?: string): Promise<any> {
        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.COMMAND_EXECUTION,
            payload: {
                command,
                workingDirectory
            }
        };

        return this.sendMessage(message);
    }

    /**
     * Sends a chat message to the server
     */
    public async sendChatMessage(content: string, conversationId: string = 'default', streaming: boolean = true): Promise<any> {
        console.log(`\nüì® [MCPClient.sendChatMessage] Chat mesajƒ± g√∂nderiliyor`);
        console.log(`üìù [MCPClient.sendChatMessage] ƒ∞√ßerik: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`);
        console.log(`üîå [MCPClient.sendChatMessage] Socket durumu: ${this.socket ? `ReadyState: ${this.socket.readyState}` : 'Socket yok!'}`);
        console.log(`‚úÖ [MCPClient.sendChatMessage] Baƒülantƒ± durumu: ${this.isConnected ? 'Baƒülƒ±' : 'Baƒülƒ± deƒüil'}`);
        console.log(`üí® [MCPClient.sendChatMessage] Streaming: ${streaming ? 'Evet' : 'Hayƒ±r'}`);
        
        // More detailed socket diagnostics
        if (this.socket) {
            console.log(`üîç [MCPClient.sendChatMessage] Socket details: readyState=${this.socket.readyState} (${this.socket.readyState === WS_OPEN ? 'OPEN' : this.socket.readyState === WS_CONNECTING ? 'CONNECTING' : this.socket.readyState === WS_CLOSING ? 'CLOSING' : 'CLOSED'})`);
            console.log(`üîç [MCPClient.sendChatMessage] Socket bufferedAmount: ${this.socket.bufferedAmount}`);
            console.log(`üîç [MCPClient.sendChatMessage] Socket protocol: ${this.socket.protocol || 'none'}`);
        }

        // Socket baƒülantƒ±sƒ± kontrol√º
        if (!this.isConnectedToServer()) {
            console.error('‚ùå [MCPClient.sendChatMessage] SmileAgent Server\'a baƒülƒ± deƒüil! Baƒülantƒ± kuruluyor...');
            try {
                await this.connect();
                console.log('‚úÖ [MCPClient.sendChatMessage] Baƒülantƒ± ba≈üarƒ±yla kuruldu, mesaj g√∂nderimi devam edecek');
                
                // Double-check socket status after connection
                console.log(`üîÑ [MCPClient.sendChatMessage] Connection reestablished, rechecking socket: ${this.socket ? `ReadyState: ${this.socket.readyState}` : 'Socket still null!'}`);
                console.log(`üîÑ [MCPClient.sendChatMessage] isConnected flag: ${this.isConnected}`);
                
                // Ensure we're really connected
                if (!this.socket || this.socket.readyState !== WS_OPEN) {
                    console.error('‚ùå [MCPClient.sendChatMessage] Reconnection failed to create a valid socket!');
                    throw new Error('Reconnection attempt did not result in an open socket');
                }
            } catch (error) {
                console.error('‚ùå [MCPClient.sendChatMessage] Baƒülantƒ± hatasƒ±:', error);
                throw new Error('Unable to connect to SmileAgent Server');
            }
        }
        
        // WebSocket hazƒ±r mƒ±?
        if (this.socket?.readyState !== WS_OPEN) {
            console.error(`‚ùå [MCPClient.sendChatMessage] Socket durumu uygun deƒüil: ${this.socket ? this.socket.readyState : 'Socket yok'}`);
            throw new Error('WebSocket is not in OPEN state');
        }

        // Create message object - CHAT_MESSAGE tipini sabit tut
        const messageId = uuidv4();
        const message: McpMessage = {
            id: messageId,
            type: McpMessageType.CHAT_MESSAGE, // Sabit tip - enum kullan
            payload: {
                content,
                conversationId,
                streaming
            }
        };

        // Double-check that we're using the correct enum value
        console.log(`üîë [MCPClient.sendChatMessage] Mesaj tipi: ${message.type}`);
        console.log(`üîç [MCPClient.sendChatMessage] Enum deƒüeri: ${McpMessageType.CHAT_MESSAGE}`);
        console.log(`üß™ [MCPClient.sendChatMessage] Tip kontrol√º: ${message.type === McpMessageType.CHAT_MESSAGE ? 'EVET' : 'HAYIR'}`);

        if (streaming) {
            console.log('üîÑ [MCPClient.sendChatMessage] Streaming mesaj g√∂nderiliyor, Event emitter bekleniyor');
            
            // Streaming mode - we don't wait for a response from sendMessage
            // Instead we expect 'chat-stream' events to be emitted
            try {
                this.sendMessageWithoutWaiting(message);
                console.log('‚úÖ [MCPClient.sendChatMessage] Streaming mesaj g√∂nderildi, messageId:', messageId);
                
                // Return a promise that will resolve when the streaming is complete
                return new Promise((resolve, reject) => {
                    let fullContent = '';
                    let lastChunk: { content: string; status: string; originalMessageId: string } | null = null;
                    
                    const onStreamData = (data: any) => {
                        console.log(`üì• [MCPClient.sendChatMessage] Stream veri alƒ±ndƒ±, status: ${data.status}`);
                        
                        // Check if this is a response to our message
                        if (data.originalMessageId === messageId) {
                            if (data.status === 'completed') {
                                console.log('‚úì [MCPClient.sendChatMessage] Streaming tamamlandƒ±');
                                
                                // Clean up event listeners
                                this.removeListener('chat-stream', onStreamData);
                                this.removeListener('error', onError);
                                
                                // Resolve with the complete response
                                resolve({
                                    content: data.content || fullContent,
                                    status: 'completed',
                                    messageId
                                });
                            } else if (data.status === 'streaming') {
                                // Update the full content with this chunk
                                fullContent = data.content;
                                lastChunk = data;
                            }
                        } else {
                            console.log(`‚ö†Ô∏è [MCPClient.sendChatMessage] Farklƒ± mesaj i√ßin stream alƒ±ndƒ±: ${data.originalMessageId} (beklenen: ${messageId})`);
                        }
                    };
                    
                    const onError = (error: Error) => {
                        console.error('‚ùå [MCPClient.sendChatMessage] Stream error:', error);
                        
                        // Clean up event listeners
                        this.removeListener('chat-stream', onStreamData);
                        this.removeListener('error', onError);
                        
                        reject(error);
                    };
                    
                    // Set up event listeners
                    this.on('chat-stream', onStreamData);
                    this.on('error', onError);
                    
                    // Set up a timeout to automatically resolve if we don't get a "completed" status
                    setTimeout(() => {
                        // If we have received something but not the completed event
                        if (lastChunk && !this.listeners('chat-stream').includes(onStreamData)) {
                            console.warn('‚ö†Ô∏è [MCPClient.sendChatMessage] Streaming zaman a≈üƒ±mƒ±, son alƒ±nan chunk ile tamamlanƒ±yor');
                            
                            // Clean up event listeners
                            this.removeListener('chat-stream', onStreamData);
                            this.removeListener('error', onError);
                            
                            resolve({
                                content: fullContent,
                                status: 'completed',
                                messageId
                            });
                        }
                    }, 60000); // 60 seconds timeout
                });
            } catch (error) {
                console.error('‚ùå [MCPClient.sendChatMessage] Streaming mesaj g√∂nderme hatasƒ±:', error);
                throw error;
            }
        } else {
            console.log('üîÑ [MCPClient.sendChatMessage] Non-streaming mesaj g√∂nderiliyor');
            
            // Non-streaming mode - we wait for a CHAT_RESPONSE message
            try {
                return await this.sendMessage(message);
            } catch (error) {
                console.error('‚ùå [MCPClient.sendChatMessage] Non-streaming mesaj g√∂nderme hatasƒ±:', error);
                throw error;
            }
        }
    }

    /**
     * Bir mesajƒ± yanƒ±t beklemeden g√∂nderir (streaming i√ßin)
     */
    private sendMessageWithoutWaiting(message: McpMessage): void {
        // Add debug logging to show more details about the message being sent
        console.log('\nüîç [MCPClient.sendMessageWithoutWaiting] DEBUG - Message object structure:');
        console.log('üîë Message ID:', message.id);
        console.log('üìù Message Type:', message.type);
        console.log('üì¶ Payload:', JSON.stringify(message.payload, null, 2));
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

        // Force a fresh socket check rather than relying on class variables
        const isSocketReady = this.socket !== null && (this.socket.readyState as number) === WS_OPEN;
        
        if (!isSocketReady) {
            console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Socket is not in OPEN state!');
            console.log(`üîå [MCPClient.sendMessageWithoutWaiting] Socket details: ${this.socket ? `readyState=${this.socket.readyState} (${(this.socket.readyState as number) === WS_OPEN ? 'OPEN' : (this.socket.readyState as number) === WS_CONNECTING ? 'CONNECTING' : (this.socket.readyState as number) === WS_CLOSING ? 'CLOSING' : 'CLOSED'})` : 'Socket is null'}`);
            
            // Only attempt reconnection if socket is null or closed
            if (!this.socket || (this.socket.readyState as number) === WS_CLOSED) {
                console.log('üîÑ [MCPClient.sendMessageWithoutWaiting] Trying to reestablish connection...');
                
                // Convert to Promise-based reconnection with retry
                this.ensureSocketIsReady()
                    .then(socket => {
                        if (socket) {
                            try {
                                const messageStr = JSON.stringify(message);
                                socket.send(messageStr);
                                console.log('‚úÖ [MCPClient.sendMessageWithoutWaiting] Message sent after reconnection');
                            } catch (retryError) {
                                console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Failed to send after reconnection:', retryError);
                                this.emit('error', new Error(`Failed to send message after reconnection: ${retryError}`));
                            }
                        } else {
                            console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Could not get a ready socket after multiple attempts');
                            this.emit('error', new Error('Could not get a ready socket after multiple attempts'));
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Error during reconnection:', error);
                        this.emit('error', new Error(`Reconnection failed: ${error}`));
                    });
                
                return; // Important: Don't throw an error here, just return
            } else if (this.socket && (this.socket.readyState as number) === WS_CONNECTING) {
                // If socket is connecting, wait for it to open and then send
                console.log('‚è≥ [MCPClient.sendMessageWithoutWaiting] Socket is connecting, will send when ready...');
                
                const onOpen = () => {
                    if (this.socket) {
                        try {
                            const messageStr = JSON.stringify(message);
                            this.socket.send(messageStr);
                            console.log('‚úÖ [MCPClient.sendMessageWithoutWaiting] Message sent after socket connected');
                        } catch (sendError) {
                            console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Failed to send after connection:', sendError);
                            this.emit('error', new Error(`Failed to send message after connection: ${sendError}`));
                        }
                        this.socket.removeEventListener('open', onOpen);
                    }
                };
                
                this.socket.addEventListener('open', onOpen);
                return;
            } else {
                // Socket is in CLOSING state, wait and try to reconnect
                console.warn('‚ö†Ô∏è [MCPClient.sendMessageWithoutWaiting] Socket is in CLOSING state, waiting to reconnect...');
                
                setTimeout(() => {
                    this.sendMessageWithoutWaiting(message);
                }, 1000); // Wait 1 second and try again
                
                return;
            }
        }

        try {
            // Socket is ready, send the message
            if (!this.socket) {
                throw new Error("Socket is unexpectedly null");
            }
            
            const messageStr = JSON.stringify(message);
            this.socket.send(messageStr);
            console.log('‚úÖ [MCPClient.sendMessageWithoutWaiting] Message sent successfully');
        } catch (error) {
            console.error('‚ùå [MCPClient.sendMessageWithoutWaiting] Error sending message:', error);
            this.emit('error', new Error(`Failed to send message: ${error}`));
        }
    }

    /**
     * Ensures that the socket is ready before sending a message
     * Returns a promise that resolves with the ready socket or null if it couldn't be made ready
     */
    private async ensureSocketIsReady(): Promise<WebSocket.WebSocket | null> {
        // Try to connect up to 3 times
        for (let attempt = 1; attempt <= 3; attempt++) {
            console.log(`üîÑ [MCPClient.ensureSocketIsReady] Attempt ${attempt}/3 to get ready socket`);
            
            try {
                await this.connect();
                
                if (this.socket && (this.socket.readyState as number) === 1) {
                    console.log('‚úÖ [MCPClient.ensureSocketIsReady] Socket is now ready');
                    return this.socket;
                } else {
                    console.warn(`‚ö†Ô∏è [MCPClient.ensureSocketIsReady] Socket still not ready after connect() call. State: ${this.socket ? this.socket.readyState : 'null'}`);
                    
                    // If socket is connecting, wait for it to open
                    if (this.socket && (this.socket.readyState as number) === 0) {
                        console.log('‚è≥ [MCPClient.ensureSocketIsReady] Socket is connecting, waiting for open event...');
                        
                        await new Promise<void>((resolve, reject) => {
                            if (!this.socket) {
                                reject(new Error("Socket is unexpectedly null"));
                                return;
                            }
                            
                            const onOpen = () => {
                                this.socket?.removeEventListener('open', onOpen);
                                this.socket?.removeEventListener('error', onError);
                                resolve();
                            };
                            
                            const onError = (error: any) => {
                                this.socket?.removeEventListener('open', onOpen);
                                this.socket?.removeEventListener('error', onError);
                                reject(error);
                            };
                            
                            this.socket.addEventListener('open', onOpen);
                            this.socket.addEventListener('error', onError);
                            
                            // Set a timeout in case the socket never opens
                            setTimeout(() => {
                                this.socket?.removeEventListener('open', onOpen);
                                this.socket?.removeEventListener('error', onError);
                                reject(new Error("Socket connection timeout"));
                            }, 5000);
                        });
                        
                        if (this.socket && (this.socket.readyState as number) === 1) {
                            console.log('‚úÖ [MCPClient.ensureSocketIsReady] Socket is now open after waiting');
                            return this.socket;
                        }
                    }
                }
            } catch (error) {
                console.error(`‚ùå [MCPClient.ensureSocketIsReady] Connection attempt ${attempt} failed:`, error);
            }
            
            // Wait before next attempt
            if (attempt < 3) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        console.error('‚ùå [MCPClient.ensureSocketIsReady] Failed to get ready socket after 3 attempts');
        return null;
    }

    /**
     * Mesajƒ± sunucuya g√∂nderir ve yanƒ±tƒ± bekler
     */
    private async sendMessage(message: McpMessage): Promise<any> {
        console.log(`\nüì§ [MCPClient.sendMessage] Mesaj g√∂nderiliyor, ID: ${message.id}, Tip: ${message.type}`);
        
        if (!this.isConnectedToServer()) {
            console.error('‚ùå [MCPClient.sendMessage] SmileAgent Server\'a baƒülƒ± deƒüil veya soket hazƒ±r deƒüil');
            throw new Error('Not connected to SmileAgent Server');
        }
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                console.error(`‚è±Ô∏è [MCPClient.sendMessage] Yanƒ±t zaman a≈üƒ±mƒ±na uƒüradƒ±, ID: ${message.id}`);
                
                if (this.pendingMessages.has(message.id)) {
                    this.pendingMessages.delete(message.id);
                    reject(new Error('Response timeout'));
                }
            }, 30000); // 30 saniye zaman a≈üƒ±mƒ±
            
            this.pendingMessages.set(message.id, {
                resolve,
                reject,
                timeout
            });
            
            try {
                this.sendMessageWithoutWaiting(message);
                console.log('‚úÖ [MCPClient.sendMessage] Mesaj ba≈üarƒ±yla g√∂nderildi, yanƒ±t bekleniyor...');
            } catch (error) {
                console.error('‚ùå [MCPClient.sendMessage] Mesaj g√∂nderirken hata:', error);
                clearTimeout(timeout);
                this.pendingMessages.delete(message.id);
                reject(error);
            }
        });
    }

    /**
     * Sunucudan gelen mesajlarƒ± i≈üler
     */
    private handleMessage(message: McpMessage): void {
        // Enhanced debugging for incoming messages
        console.log(`\nüîç [MCPClient.handleMessage] DEBUG - Incoming message details:`);
        console.log(`üÜî Message ID: ${message.id}`);
        console.log(`üìã Message Type: ${message.type}`);
        console.log(`üì¶ Payload preview: ${JSON.stringify(message.payload).substring(0, 300)}...`);
        console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
        
        this.emit('message', message);

        console.log(`\nüîç [MCPClient.handleMessage] Alƒ±nan mesaj tipi: ${message.type}`);
        console.log(`üìÑ [MCPClient.handleMessage] Detaylar: ${JSON.stringify(message.payload).substring(0, 100)}...`);

        switch (message.type) {
            case McpMessageType.INIT:
                console.log('üöÄ [MCPClient.handleMessage] Init mesajƒ± alƒ±ndƒ±');
                
                // ƒ∞lk baƒülantƒ± sonrasƒ± test sorgusu yapalƒ±m
                if (message.payload.message && message.payload.message.includes('Connected to SmileAgent Server')) {
                    console.log('‚úÖ [MCPClient.handleMessage] Ba≈üarƒ±lƒ± baƒülantƒ± mesajƒ± alƒ±ndƒ±');
                    
                    // Eƒüer bekleyen mesaj varsa, yeniden g√∂ndermeyi dene
                    if (this.pendingMessages.size > 0) {
                        console.log(`‚ö†Ô∏è [MCPClient.handleMessage] ${this.pendingMessages.size} bekleyen mesaj var. Bunlarƒ± g√∂ndermeyi yeniden deneyeceƒüiz...`);
                        
                        // 1 saniye sonra √ßalƒ±≈ütƒ±r
                        setTimeout(() => {
                            // Kullanƒ±cƒ±ya hata bildirimi sunma, √ß√ºnk√º arka planda yeniden deneyeceƒüiz
                            console.log("üîÑ [MCPClient.handleMessage] Sorgu yeniden g√∂nderilecek...");
                        }, 1000);
                    }
                }
                this.emit('init', message.payload);
                break;
            case McpMessageType.RESPONSE:
                this.handleResponseMessage(message);
                break;
            case McpMessageType.ERROR:
                this.handleErrorMessage(message);
                break;
            case McpMessageType.CHAT_RESPONSE:
                console.log('üí¨ [MCPClient.handleMessage] Chat yanƒ±tƒ± alƒ±ndƒ±');
                console.log('üîç [MCPClient.handleMessage] DEBUG - Chat response payload:', JSON.stringify(message.payload, null, 2));
                this.handleChatResponseMessage(message);
                break;
            case McpMessageType.CHAT_STREAM:
                console.log('üì≤ [MCPClient.handleMessage] Chat stream chunk alƒ±ndƒ±');
                console.log('üîç [MCPClient.handleMessage] DEBUG - Chat stream payload:', JSON.stringify(message.payload, null, 2));
                this.handleChatStreamMessage(message.payload);
                break;
            default:
                console.log(`‚ö†Ô∏è [MCPClient.handleMessage] ƒ∞≈ülenmeyen mesaj tipi: ${message.type}`);
        }
    }

    /**
     * Yanƒ±t mesajlarƒ±nƒ± i≈üler
     */
    private handleResponseMessage(message: McpMessage): void {
        console.log('üì• [MCPClient.handleResponseMessage] Yanƒ±t mesajƒ± i≈üleniyor...');
        
        const originalMessageId = message.payload.originalQueryId;
        if (originalMessageId && this.pendingMessages.has(originalMessageId)) {
            console.log('‚úÖ [MCPClient.handleResponseMessage] Bekleyen istek bulundu, ID:', originalMessageId);
            
            const pendingMessage = this.pendingMessages.get(originalMessageId)!;
            clearTimeout(pendingMessage.timeout);
            this.pendingMessages.delete(originalMessageId);
            
            console.log('\nüì• [MCPClient.handleResponseMessage] MCP yanƒ±tƒ± alƒ±ndƒ±:');
            if (message.payload.result && message.payload.result.message) {
                console.log(`üí¨ [MCPClient.handleResponseMessage] Yanƒ±t: ${message.payload.result.message.substring(0, 50)}${message.payload.result.message.length > 50 ? '...' : ''}`);
            } else if (message.payload.result) {
                console.log(`üí¨ [MCPClient.handleResponseMessage] Yanƒ±t: ${JSON.stringify(message.payload.result).substring(0, 100)}...`);
            } else {
                console.log('‚ö†Ô∏è [MCPClient.handleResponseMessage] Yanƒ±t i√ßeriƒüi yok veya bo≈ü');
            }
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
            
            pendingMessage.resolve(message.payload.result);
        } else {
            console.warn('‚ö†Ô∏è [MCPClient.handleResponseMessage] Bekleyen istek bulunamadƒ± veya e≈üle≈üme yok, ID:', originalMessageId || 'undefined');
        }
    }

    /**
     * Hata mesajlarƒ±nƒ± i≈üler
     */
    private handleErrorMessage(message: McpMessage): void {
        console.error('‚ùå [MCPClient.handleErrorMessage] Hata mesajƒ± alƒ±ndƒ±');
        
        const originalMessageId = message.payload.originalMessageId;
        if (originalMessageId && this.pendingMessages.has(originalMessageId)) {
            console.log('‚úÖ [MCPClient.handleErrorMessage] Bekleyen istek bulundu, ID:', originalMessageId);
            
            const pendingMessage = this.pendingMessages.get(originalMessageId)!;
            clearTimeout(pendingMessage.timeout);
            this.pendingMessages.delete(originalMessageId);
            
            console.error('\n‚ùå [MCPClient.handleErrorMessage] MCP hata mesajƒ± alƒ±ndƒ±:');
            console.error(`üí¨ [MCPClient.handleErrorMessage] Hata mesajƒ±: ${message.payload.message}`);
            console.error(`üìÑ [MCPClient.handleErrorMessage] Detaylar: ${JSON.stringify(message.payload.details).substring(0, 100)}...`);
            console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        } else {
            console.warn('‚ö†Ô∏è [MCPClient.handleErrorMessage] Bekleyen istek bulunamadƒ± veya e≈üle≈üme yok, ID:', originalMessageId || 'undefined');
        }
    }

    /**
     * Chat yanƒ±tƒ± mesajlarƒ±nƒ± i≈üler
     */
    private handleChatResponseMessage(message: McpMessage): void {
        console.log('üí¨ [MCPClient.handleChatResponseMessage] Chat yanƒ±tƒ± mesajƒ± i≈üleniyor...');
        
        const originalMessageId = message.payload.originalMessageId;
        if (originalMessageId && this.pendingMessages.has(originalMessageId)) {
            console.log('‚úÖ [MCPClient.handleChatResponseMessage] Bekleyen istek bulundu, ID:', originalMessageId);
            
            const pendingMessage = this.pendingMessages.get(originalMessageId)!;
            clearTimeout(pendingMessage.timeout);
            this.pendingMessages.delete(originalMessageId);
            
            console.log('\nüí¨ [MCPClient.handleChatResponseMessage] Chat yanƒ±tƒ± alƒ±ndƒ±:');
            console.log(`üí¨ [MCPClient.handleChatResponseMessage] Yanƒ±t: ${message.payload.message.substring(0, 50)}${message.payload.message.length > 50 ? '...' : ''}`);
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
            
            pendingMessage.resolve(message.payload.message);
        } else {
            console.warn('‚ö†Ô∏è [MCPClient.handleChatResponseMessage] Bekleyen istek bulunamadƒ± veya e≈üle≈üme yok, ID:', originalMessageId || 'undefined');
        }
    }

    /**
     * Chat stream mesajlarƒ±nƒ± i≈üler
     */
    private handleChatStreamMessage(payload: any): void {
        console.log('üì≤ [MCPClient.handleChatStreamMessage] Chat stream mesajƒ± i≈üleniyor...');
        console.log(`üîç [MCPClient.handleChatStreamMessage] DEBUG - Payload:`, JSON.stringify(payload, null, 2));
        
        // Received stream chunk will always emit an event rather than resolve a promise
        this.emit('chat-stream', payload);
        console.log(`üì¢ [MCPClient.handleChatStreamMessage] 'chat-stream' event emitted with status: ${payload.status}`);
        
        // If this is a final chunk (completed status), and there is a pending message, resolve it
        const originalMessageId = payload.originalMessageId;
        if (payload.status === 'completed' && originalMessageId && this.pendingMessages.has(originalMessageId)) {
            console.log('‚úÖ [MCPClient.handleChatStreamMessage] Bekleyen istek tamamlandƒ±, ID:', originalMessageId);
            
            const pendingMessage = this.pendingMessages.get(originalMessageId)!;
            clearTimeout(pendingMessage.timeout);
            this.pendingMessages.delete(originalMessageId);
            
            pendingMessage.resolve(payload);
        } else if (payload.status === 'completed') {
            console.log('‚ÑπÔ∏è [MCPClient.handleChatStreamMessage] Tamamlanan mesaj i√ßin bekleyen istek bulunamadƒ±, ID:', originalMessageId || 'undefined');
        }
    }

    /**
     * Sunucuya baƒülantƒ± kontrol√º
     */
    public isConnectedToServer(): boolean {
        // Enhanced socket check for better reliability
        const socketIsValid = this.socket !== null && 
                             (this.socket.readyState as number) === WS_OPEN;
        
        // Check if our internal state agrees with the socket state
        if (this.isConnected !== socketIsValid) {
            console.warn(`‚ö†Ô∏è [MCPClient.isConnectedToServer] Inconsistent connection state detected!`);
            console.warn(`‚ö†Ô∏è [MCPClient.isConnectedToServer] this.isConnected=${this.isConnected}, but socket is ${socketIsValid ? 'valid' : 'invalid'}`);
            console.warn(`‚ö†Ô∏è [MCPClient.isConnectedToServer] Socket details: ${this.socket ? `readyState=${this.socket.readyState}` : 'Socket is null'}`);
            
            // Update our flag to match reality - otherwise we'll continuously try to reconnect
            this.isConnected = socketIsValid;
        }
        
        return this.isConnected;
    }

    /**
     * Yeniden baƒülantƒ± dene
     */
    private attemptReconnect(): void {
        if (this.reconnectAttempts < this.config.maxReconnectAttempts!) {
            this.reconnectAttempts++;
            console.log(`üîÑ [MCPClient.attemptReconnect] ${this.reconnectAttempts}. baƒülantƒ± denemesi...`);
            this.connect().then(() => {
                console.log('‚úÖ [MCPClient.attemptReconnect] Baƒülantƒ± ba≈üarƒ±yla kuruldu');
            }).catch((error) => {
                console.error('‚ùå [MCPClient.attemptReconnect] Baƒülantƒ± kurulurken hata:', error);
                setTimeout(() => this.attemptReconnect(), this.config.reconnectInterval!);
            });
        } else {
            console.error('‚ùå [MCPClient.attemptReconnect] Maksimum baƒülantƒ± deneme sayƒ±sƒ±na ula≈üƒ±ldƒ±');
            this.emit('error', new Error('Maximum reconnection attempts reached'));
        }
    }

    /**
     * Dispose method
     */
    public dispose(): void {
        this.disconnect();
    }
}
